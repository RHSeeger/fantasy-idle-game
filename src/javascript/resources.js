
import * as Population from './population.js';
import * as Miscellaneous from './miscellaneous.js';
import * as Races from './races.js';
import * as Terrain from './terrain.js';
import * as Buildings from './buildings.js';

/********************************************************
 * FOOD
 * Food is a perishable resource - any food not used during a turn is converted to gold
 */

function getNumRequiredFood() {
    // It's pretty much always one food per unit, unless we have some modifier
    // In theory, each normal unit uses one food too... but not sure how we're handling units yet
    // TODO: add in the amount used by normal units (ie, combat units)
    return Population.getPopulationUnits();
}

/**
 * Returns the amount of food generated by the various source
 * - base food level (the the land, etc)
 * - required farmers + optional farmers
 * - other buildings and the like
 * There's 2 categories of produced food
 * - weighted - food generation that, if over the base food level, if halved
 * - unweighted - food generation that is not reduced by being over the base food level
 */
function calculateFoodGenerated() {
    var baseFoodLevel = calculateBaseFoodLevel();

    const foodPerFarmer = Population.getFoodPerFarmer();
    const totalFarmers = Population.getNumRequiredFarmers() + Population.getNumOptionalFarmers();

    // The amount of farmed and weighted produced food if every farmer is working at max production
    const maxFarmedFood = totalFarmers * foodPerFarmer;
    const maxWeightedFood = maxFarmedFood + (Buildings.hasBuilding(Buildings.BUILDINGS.FORESTERS_GUILD) ? 2 : 0);

    // The amount of weighted food generated after reducing by half the amount over the base food level
    const weightedFood = (maxWeightedFood <= baseFoodLevel) ? baseFoodLevel
        : maxWeightedFood - ((maxWeightedFood - baseFoodLevel) / 2.0);

    // Now we move on to the unweighted food generation types
    const granaryFood = Buildings.hasBuilding(Buildings.BUILDINGS.GRANARY) ? 2 : 0;
    const marketFood = Buildings.hasBuilding(Buildings.BUILDINGS.FARMERS_MARKET) ? 3 : 0;
    const wildGameModifier = 1; //TODO:  2 for each Wild game in the city's catchment area
    const unweightedFood = (granaryFood + marketFood) * wildGameModifier;

    const totalFoodProduced = baseFoodLevel + weightedFood + unweightedFood;

    //console.log("numRequiredFarmers = [" + getNumRequiredFarmers() + "]"
    //    + ", numOptionalFarmers = [" + getNumOptionalFarmers() + "]"
    //    + ", foodPerFarmer = [" + foodPerFarmer + "]"
    //    + ", numFarmedFood = [" + farmedFoodIfAllFullProduction + "]"
    //    + ", baseFoodLevel = [" + baseFoodLevel + "]"
    //    + ", producedFood = [" + producedFood + "]"
    //    + ", totalFoodProduced = [" + totalFoodProduced + "]");

    return totalFoodProduced;
}

function calculateBaseFoodLevel() {
    var baseFoodLevel =
        (0.5 * 0) // 0.5 for each Forest, Gill, or Short in its catchment area
        + (1.5 * 0) // 1.5 for each Grassland in its catchment area
        + (2 * 0) // 2 for each River, River Mouth, or Sorcery Node in its catchment area
        + (2.5 * 0); // 2.5 for each Nature Node in its catchment area
    if (false) {// if the city has Gaia's Blessing case on it
        baseFoodLevel *= 1.5;
    }

    return baseFoodLevel;
}


/***********************************************************
 * GOLD
 * Gold is a collectible resource - it accumulates over time
 */
function calculateGoldProduced() {
    const base = calculateBaseGold();
    const bonus = calculateGoldBonus();
    const tradeGoods = calculateTradeGoodGoldBonus();

    // TODO: We don't seem to include excess food here... should we?

    return Math.floor(base * bonus) + tradeGoods;
}

function calculateBaseGold() {
    // From taxes
    const taxRaceMultiplier = Population.getPrimaryRace() == Races.RACES.dwarf ? 2
        : Population.getSecondaryRaces().includes(Races.RACES.DWARF) ? 1.25
        : 1;
    const numTaxablePopulationUnits = Population.getPopulationUnits() - Population.getPopulationRebelUnits();
    const taxGold = numTaxablePopulationUnits * Miscellaneous.getTaxRate() * taxRaceMultiplier;

    // From minerals
    const mineralsRaceModifier = Population.getPrimaryRace() == Races.RACES.DWARF ? 2
        : Population.getSecondaryRaces().includes(Races.RACES.DWARF) ? 1.25
        : 1;
    const mineralsBuildingModified = Buildings.hasBuilding(Buildings.BUILDINGS.MINERS_GUILD) ? 1.5 : 1;
    const mineralValue = [
        Terrain.TERRAIN_SPECIALS.SILVER_ORE,
        Terrain.TERRAIN_SPECIALS.GOLD_ORE,
        Terrain.TERRAIN_SPECIALS.GEMS]
        .map(terrainType => {
            const count = Terrain.getTerrainSpecialTypeCount(terrainType);
            return count * Terrain.TERRAIN_SPECIALS_DATA[terrainType].goldValue;
        })
        .reduce((accumulator, currentValue) => accumulator + currentValue);
    const mineralGold = mineralValue * mineralsBuildingModified * mineralsRaceModifier;

    return Math.floor(taxGold) + Math.floor(mineralGold);
}

/**
 * Calculate the bonus to gold
 * Calculations are done in percentage amount, then divided by 100 at the end
 */
function calculateGoldBonus() {
    // TODO: account for terrain, race, connected cities (count of cities other than the non-primary), etc
    const tradeBonus = 50;

    const buildingBonus = 0
        + (Buildings.hasBuilding(Buildings.BUILDINGS.MARKETPLACE) ? 50 : 0)
        + (Buildings.hasBuilding(Buildings.BUILDINGS.BANK) ? 50 : 0)
        + (Buildings.hasBuilding(Buildings.BUILDINGS.MERCHANTS_GUILD) ? 100 : 0);

    return (tradeBonus + buildingBonus) / 100.0;
}

/**
 * Trade Goods is a production project which produces gold instead of a building.
 */
function calculateTradeGoodGoldBonus() {
    // TODO: this
    return 0;
}

/**
 * In MOM, this doesn't include units, just buildings... not sure if we want to change that
 */
function calculateGoldUpkeep() {
    //return 65;
    const allBuildings = Buildings.getAllBuildings();

    const buildingUpkeep = Buildings.getAllBuildings()
        .filter(building => Buildings.hasBuilding(building))
        .map(building => Buildings.BUILDINGS_DATA[building].upkeepGold)
        .reduce((accumulator, currentValue) => accumulator + currentValue);

    return buildingUpkeep;
}

/*********************************************************************
 * PRODUCTION
 * Production is a perishable resource - any production not used during a turn is lost
 */

function calculateProductionGenerated() {
    return calculateProductionBase() * calculateProductionBonusMultiplier();
}

function calculateProductionBase() {
    const numFarmers = Population.getNumRequiredFarmers() + Population.getNumOptionalFarmers();
    const numRioters = Population.calculateNumRioters();
    const numWorkers = Population.getPopulationUnits() - (numFarmers + numRioters);

    const primaryRace = Population.getPrimaryRace();
    const primaryRaceWorkerGenerated = (primaryRace === Races.RACES.KLACKON || primaryRace === Races.RACES.DWARF) ? 3 : 2;
    const secondaryRaces = Population.getSecondaryRaces()
    const secondaryRacesWorkerGenerated = (secondaryRaces.includes(Races.RACES.DWARF) ? 0.5 : 0)
        + (secondaryRaces.includes(Races.RACES.DWARF) ? 0.5 : 0)
    const baseProduction = (numFarmers * 0.5)+ (numWorkers * (primaryRaceWorkerGenerated + secondaryRacesWorkerGenerated))
    return baseProduction;
}

/**
 * A return value of 1 means no modifier, 0.5 would be half production, 2.0 would be double production
 */
function calculateProductionBonusMultiplier() {
    const terrainModifier = 0; // TODO: this
    // mountain, chaos node == +5%
    // desert, forest, hill, nature node == +3%
    // Gaia's Blessing doubles the benefit from forests

    const buildingModified = 0
        + (Buildings.hasBuilding(Buildings.BUILDINGS.SAWMILL) ? 25 : 0)
        + (Buildings.hasBuilding(Buildings.BUILDINGS.FORESTERS_GUILD) ? 25 : 0)
        + (Buildings.hasBuilding(Buildings.BUILDINGS.MINERS_GUILD) ? 50 : 0)
        + (Buildings.hasBuilding(Buildings.BUILDINGS.MECHANICIANS_GUILD) ? 50 : 0);

    const enchantmentModifiedAdditive = 0; // TODO: this
    // Inspirations = +100%
    const enchantmentModifierMultiplicative = 100; // TODO: this
    // Cursed Lands = 50

    const modifier = ((100 + terrainModifier + buildingModified + enchantmentModifiedAdditive) / 100.0)
        * (enchantmentModifierMultiplicative / 100)

    return modifier;
}

/**
 * EXPORT
 */
export {
    getNumRequiredFood, calculateFoodGenerated, calculateBaseFoodLevel,
    calculateGoldProduced, calculateGoldUpkeep,
    calculateProductionGenerated
    };
